/*
 * Copyright (C) 2005-2015 Schlichtherle IT Services.
 * All rights reserved. Use is subject to license terms.
 */

#if($licenseKeyFormat == "V2/JSON")
#set($licenseManagementContextPackage = "org.truelicense.v2.json")
#set($licenseManagementContextClass = "V2JsonLicenseManagementContext")
#elseif($licenseKeyFormat == "V2/XML")
#set($licenseManagementContextPackage = "org.truelicense.v2.xml")
#set($licenseManagementContextClass = "V2XmlLicenseManagementContext")
#elseif($licenseKeyFormat == "V1")
#set($licenseManagementContextPackage = "org.truelicense.v1")
#set($licenseManagementContextClass = "V1LicenseManagementContext")
#end
#set($editions = $editions.split($delimiter))
#set($editionsSize = $editions.size())
#set($hash = '#')
#set($dollar = '$')
#set($english = $field.get("java.util.Locale.ENGLISH"))
#set($preferencesType = $display.capitalize($preferencesType.toLowerCase($english)))
#macro(password $string)$java.obfuscatedString($string).replace("org.truelicense.obfuscate.", "")#end
/* Generated from Velocity template at $date - DO NOT EDIT! */
package ${package}.keymgr;

import javax.annotation.concurrent.Immutable;
import org.truelicense.api.*;
import org.truelicense.api.io.Source;
import $licenseManagementContextPackage.$licenseManagementContextClass;
import org.truelicense.obfuscate.*;
#if($keyMgrClockClass != "-")
import org.truelicense.api.misc.Clock;
import java.util.Date;
#end

/**
 * The enumeration of the license consumer managers for $licensingSubject
 * license keys.
 * The managers are named like each configured edition and ordered from
 * superset to subset, including an optional free trial period (FTP).
 * Each manager is configured with the algorithms and parameters for installing,
 * viewing, verifying and uninstalling license keys for the respective edition.
 *
 * @author Christian Schlichtherle
 */
@Immutable
public enum LicenseManager implements LicenseConsumerManager {
#foreach($edition in $editions)
#set($editionCertEntryAlias = $edition)
#evaluate("${hash}set (${dollar}editionCertEntryAlias = ${dollar}${edition}KeyEntryAlias)")
#set($editionPbePassword = $password)
#evaluate("${hash}set(${dollar}editionPbePassword = ${dollar}${edition}PbePassword)")

    $edition {
#if($editionCertEntryAlias == $edition)
#set($editionCertEntryAlias = "name()")
#else
        @Obfuscate
        private static final String CERT_ENTRY_ALIAS = "$editionCertEntryAlias";

#set($editionCertEntryAlias = "CERT_ENTRY_ALIAS")
#end
        @Override
        LicenseConsumerManager newManager() {
            return _context.manager()
#if($editionPbePassword != $parentEditionPbePassword)
                    .encryption()
#if($licenseKeyFormat == "V1" && $pbeAlgorithm != "PBEWithMD5AndDES" ||
    $licenseKeyFormat.startsWith("V2/") && $pbeAlgorithm != "PBEWithSHA1AndDESede")
                        .algorithm(PBE_ALGORITHM)
#end
                        .password(#password($editionPbePassword))
                        .inject()
#end
                    .keyStore()
                        .alias($editionCertEntryAlias)
                        .loadFromResource(KEY_STORE_FILE)
                        .storePassword(#password($publicKeyStorePassword))
#if($licenseKeyFormat == "V1" && $publicKeyStoreType != "JKS" ||
    $licenseKeyFormat.startsWith("V2/") && $publicKeyStoreType != "JCEKS")
                        .storeType(KEY_STORE_TYPE)
#end
                        .inject()
#if(0 < $foreach.index)
                    .parent(LicenseManager.$parentEdition)
#end
                    .storeIn${preferencesType}Preferences(Main.class) // must be a non-obfuscated class!
                    .build();
        }
    }#if($foreach.count == $editionsSize && $freeTrialPeriod == 0);#{else},#end

#set($parentEdition = $edition)
#set($parentEditionPbePassword = $editionPbePassword)
#end
#if($freeTrialPeriod != 0)
#set($ftpKeyEntryAlias = "ftp")
#evaluate("${hash}set (${dollar}ftpKeyEntryAlias = ${dollar}ftpKeyEntryAlias)")

    ftp {
#if($ftpKeyEntryAlias == "ftp")
#set($ftpKeyEntryAlias = "name()")
#else
        @Obfuscate
        private static final String KEY_ENTRY_ALIAS = "$ftpKeyEntryAlias";

#set($ftpKeyEntryAlias = "KEY_ENTRY_ALIAS")
#end
#if($ftpKeyStoreFile != $publicKeyStoreFile)
        @Obfuscate
        private static final String KEY_STORE_FILE = "$ftpKeyStoreFile";

#end
#if($licenseKeyFormat == "V1" && $ftpKeyStoreType != "JKS" ||
    $licenseKeyFormat.startsWith("V2/") && $ftpKeyStoreType != "JCEKS")
        @Obfuscate
        private static final String KEY_STORE_TYPE = "$ftpKeyStoreType";

#end
#if($customClasspathScope == "runtime")
        @Obfuscate
        private static final String SECRET_MARKER_CLASS = "$ftpSecretMarkerClass";

#end
        @Override
        LicenseConsumerManager newManager() {
            return _context.manager()
                    .ftpDays($freeTrialPeriod)
                    .keyStore()
                        .alias($ftpKeyEntryAlias)
#if($ftpKeyEntryPassword && $ftpKeyEntryPassword != $ftpKeyStorePassword)
                        .keyProtection(#password($ftpKeyEntryPassword))
#end
                        .loadFromResource(KEY_STORE_FILE)
                        .storePassword(#password($ftpKeyStorePassword))
#if($licenseKeyFormat == "V1" && $ftpKeyStoreType != "JKS" ||
    $licenseKeyFormat.startsWith("V2/") && $ftpKeyStoreType != "JCEKS")
                        .storeType(KEY_STORE_TYPE)
#end
                        .inject()
                    .parent(LicenseManager.$parentEdition)
#if($customClasspathScope == "runtime")
                    .storeIn${preferencesType}Preferences(classForName(SECRET_MARKER_CLASS))
#else
                    .storeIn${preferencesType}Preferences(${ftpSecretMarkerClass.replace('$', '.')}.class)
#end
                    .build();
        }
    };
#end
#if($customClasspathScope == "runtime" && $keyMgrClockClass != "-")

    @Obfuscate
    private static final String CLOCK_CLASS = "$keyMgrClockClass";
#end

    @Obfuscate
    private static final String KEY_STORE_FILE = "$publicKeyStoreFile";
#if($licenseKeyFormat == "V1" && $publicKeyStoreType != "JKS" ||
    $licenseKeyFormat.startsWith("V2/") && $publicKeyStoreType != "JCEKS")

    @Obfuscate
    private static final String KEY_STORE_TYPE = "$publicKeyStoreType";
#end
#if($customClasspathScope == "runtime" && $keyMgrLicenseValidationClass != "-")

    @Obfuscate
    private static final String LICENSE_VALIDATION_CLASS = "$keyMgrLicenseValidationClass";
#end

    @Obfuscate
    private static final String LICENSING_SUBJECT = "$licensingSubject";
#if($licenseKeyFormat == "V1" && $pbeAlgorithm != "PBEWithMD5AndDES" ||
    $licenseKeyFormat.startsWith("V2/") && $pbeAlgorithm != "PBEWithSHA1AndDESede")

    @Obfuscate
    private static final String PBE_ALGORITHM = "$pbeAlgorithm";
#end

    // Note that the class implementing the interface
    // org.truelicense.api.LicenseManagementContext
    // determines the format of the license keys:
    // The implementation class
    // $licenseManagementContextPackage.$licenseManagementContextClass
    // uses the license key format $licenseKeyFormat.
    private static final LicenseConsumerContext<ObfuscatedString> _context =
            new $licenseManagementContextClass(LICENSING_SUBJECT) {
#if($keyMgrClockClass != "-")

#if($customClasspathScope == "runtime")
                @SuppressWarnings("unchecked")
                final Clock clock =
                        newInstance((Class<Clock>) classForName(CLOCK_CLASS));
#else
                final Clock clock =
                        new ${keyMgrClockClass.replace('$', '.')}();
#end

                @Override public Date now() { return clock.now(); }
#end
#if($keyMgrLicenseValidationClass != "-")

                @Override public LicenseValidation validation() {
#if($keyMgrLicenseValidationFunction != "override")
                    final LicenseValidation basic = super.validation();
#end
                    return new LicenseValidation() {
#if($customClasspathScope == "runtime")
                        @SuppressWarnings("unchecked")
                        final LicenseValidation custom =
                                newInstance((Class<LicenseValidation>) classForName(LICENSE_VALIDATION_CLASS));
#else
                        final LicenseValidation custom =
                                new ${keyMgrLicenseValidationClass.replace('$', '.')}();
#end

                        public void validate(final License bean) throws LicenseValidationException {
                            custom.validate(bean);
#if($keyMgrLicenseValidationFunction != "override")
                            basic.validate(bean);
#end
                        }
                    };
                }
#end
            }.consumer();

    private volatile LicenseConsumerManager _manager;
#if($customClasspathScope == "runtime")
#if($keyMgrLicenseValidationClass != "-")

    private static <T> T newInstance(Class<T> clazz) {
        try {
            return clazz.newInstance();
        } catch (IllegalAccessException e) {
            throw new IllegalArgumentException(e);
        } catch (InstantiationException e) {
            throw new IllegalArgumentException(e);
        }
    }
#end
#if($keyMgrLicenseValidationClass != "-" || $freeTrialPeriod != 0)

    private static Class<?> classForName(final String className) {
        try {
            return Class.forName(className, false, LicenseManager.class.getClassLoader());
        } catch (ClassNotFoundException e) {
            throw new IllegalArgumentException(e);
        }
    }
#end
#end

#if($freeTrialPeriod != 0)
#set($firstEdition = "ftp")
#else
#foreach($edition in $editions)
#set($firstEdition = $edition)
#end
#end
    /**
     * Returns the first license manager in the configured
     * chain-of-responsibility, which is {@link #$firstEdition}.
     * <p>
     * By default, this manager should be used to
     * {@linkplain #install() install}, {@linkplain #view() view} and
     * {@linkplain #uninstall() uninstall} license keys.
     */
    public static LicenseManager get() { return $firstEdition; }

    private LicenseConsumerManager manager() {
        // No need to synchronize because managers are virtually stateless.
        final LicenseConsumerManager m = _manager;
        return null != m ? m : (_manager = newManager());
    }

    abstract LicenseConsumerManager newManager();

    @Override
    public void install(Source source) throws LicenseManagementException {
        manager().install(source);
    }

    @Override
    public License view() throws LicenseManagementException {
        return manager().view();
    }

    @Override
    public void verify() throws LicenseManagementException {
        manager().verify();
    }

    @Override
    public void uninstall() throws LicenseManagementException {
        manager().uninstall();
    }

    @Override
    public LicenseConsumerContext<?> context() {
        assert _context == manager().context();
        return _context;
    }

    @Override
    public String subject() {
        return manager().subject();
    }

    @Override
    public LicenseParameters parameters() {
        return manager().parameters();
    }
}
