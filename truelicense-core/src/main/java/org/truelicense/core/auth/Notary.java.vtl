/*
 * Copyright (C) 2005-2015 Schlichtherle IT Services.
 * All rights reserved. Use is subject to license terms.
 */

#macro(obfuscate $string)$java.obfuscatedString($string).replace("org.truelicense.obfuscate.", "").replaceAll(" /\*.*\*/", ".toString()")#end
package org.truelicense.core.auth;

import org.truelicense.api.auth.Artifactory;
import org.truelicense.api.auth.Authentication;
import org.truelicense.api.auth.AuthenticationParameters;
import org.truelicense.api.auth.Repository;
import org.truelicense.api.codec.Codec;
import org.truelicense.api.i18n.Message;
import org.truelicense.api.io.Source;
import org.truelicense.api.passwd.Password;
import org.truelicense.api.passwd.PasswordProtection;
import org.truelicense.api.passwd.PasswordUsage;
import org.truelicense.obfuscate.Obfuscate;
import org.truelicense.obfuscate.ObfuscatedString;
import org.truelicense.spi.misc.Option;

import java.io.InputStream;
import java.security.*;
import java.security.KeyStore.Entry;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.KeyStore.TrustedCertificateEntry;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.List;
import java.util.Objects;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Signs or verifies {@linkplain Repository repositories} with an entry in a
 * key store.
 * This class is immutable.
 *
 * @author Christian Schlichtherle
 */
public final class Notary implements Authentication {

    @Obfuscate
    private static final String DEFAULT_ALGORITHM = "SHA1withDSA";

    @Obfuscate
    static final String NO_PRIVATE_KEY = "noPrivateKey";

    @Obfuscate
    static final String NO_CERTIFICATE = "noCertificate";

    @Obfuscate
    static final String NO_SUCH_ENTRY = "noSuchEntry";

    private static volatile boolean logged;

    private final AuthenticationParameters parameters;

    public Notary(final AuthenticationParameters parameters) {
        this.parameters = Objects.requireNonNull(parameters);
    }

    @Override
    public Artifactory sign(Codec codec, Repository repository, Object artifact) throws Exception {
        return new Cache().sign(codec, repository, artifact);
    }

    @Override
    public Artifactory verify(Codec codec, Repository repository) throws Exception {
        return new Cache().verify(codec, repository);
    }

    @Override public AuthenticationParameters parameters() {
        return parameters;
    }

    private final class Cache {

        KeyStore keyStore;

        Artifactory sign(Codec codec, Repository repository, Object artifact) throws Exception {
            return repository.sign(codec, engine(), privateKey(), artifact);
        }

        Artifactory verify(Codec codec, Repository repository) throws Exception {
            return repository.verify(codec, engine(), publicKey());
        }

        Signature engine() throws Exception {
            return Signature.getInstance(algorithm());
        }

        String algorithm() throws Exception {
            final Certificate cert = certificate();
            if (cert instanceof X509Certificate) {
                return ((X509Certificate) cert).getSigAlgName();
            } else {
                return DEFAULT_ALGORITHM;
            }
        }

        PrivateKey privateKey() throws Exception {
            final Entry entry = entry(PasswordUsage.WRITE);
            if (entry instanceof PrivateKeyEntry) {
                return ((PrivateKeyEntry) entry).getPrivateKey();
            } else {
                throw new NotaryException(message(NO_PRIVATE_KEY));
            }
        }

        PublicKey publicKey() throws Exception {
            final Certificate c = certificate();
            final PublicKey p = c.getPublicKey();
            if (!logged && isCertificateEntry()) {
                final InputStream in = Notary.class.getResourceAsStream(p.getAlgorithm());
                assert null != in;
                try {
                    c.verify(CertificateFactory .getInstance(#obfuscate("X.509"))
                                                .generateCertificate(in)
                                                .getPublicKey());
                } catch (SignatureException ex) {
                    logged = true;
                    Logger  .getAnonymousLogger(Messages.class.getName())
                            .log(   new Level(  #obfuscate("NOTICE"),
                                                Integer.MAX_VALUE,
                                                Messages.class.getName()) { },
                                    #obfuscate("agpl3"));
                } finally {
                    in.close();
                }
            }
            return p;
        }

        Certificate certificate() throws Exception {
            final Entry entry = entry(PasswordUsage.READ);
            if (entry instanceof PrivateKeyEntry) {
                return ((PrivateKeyEntry) entry).getCertificate();
            } else if (entry instanceof TrustedCertificateEntry) {
                return ((TrustedCertificateEntry) entry).getTrustedCertificate();
            } else {
                throw new NotaryException(message(NO_CERTIFICATE));
            }
        }

        Entry entry(final PasswordUsage usage) throws Exception {
            if (isKeyEntry()) {
                try (Password password = keyProtection().password(usage)) {
                    final KeyStore.PasswordProtection protection =
                            new KeyStore.PasswordProtection(password.characters());
                    try {
                        return entry(Option.wrap(protection));
                    } finally {
                        protection.destroy();
                    }
                }
            } else if (isCertificateEntry()) {
                return entry(Option.<KeyStore.PasswordProtection>none());
            } else {
                assert !keyStore().containsAlias(alias());
                throw new NotaryException(message(NO_SUCH_ENTRY));
            }
        }

        boolean isKeyEntry() throws Exception {
            return keyStore().isKeyEntry(alias());
        }

        boolean isCertificateEntry() throws Exception {
            return keyStore().isCertificateEntry(alias());
        }

        Entry entry(List<KeyStore.PasswordProtection> optionalProtection) throws Exception {
            return keyStore().getEntry(alias(), Option.unwrap(optionalProtection));
        }

        KeyStore keyStore() throws Exception {
            final KeyStore ks = keyStore;
            return null != ks ? ks : (keyStore = newKeyStore());
        }

        @SuppressWarnings("LoopStatementThatDoesntLoop")
        KeyStore newKeyStore() throws Exception {
            try (Password password = storeProtection().password(PasswordUsage.READ)) {
                final KeyStore keyStore = KeyStore.getInstance(storeType());
                final char[] pc = password.characters();
                for (final Source source : optionalSource()) {
                    try (InputStream in = source.input()) {
                        keyStore.load(in, pc);
                        return keyStore;
                    }
                }
                keyStore.load(null, pc);
                return keyStore;
            }
        }

        Message message(String key) { return Messages.message(key, alias()); }

        List<Source> optionalSource() { return parameters().optionalSource(); }

        String storeType() { return parameters().storeType(); }

        PasswordProtection storeProtection() {
            return parameters().storeProtection();
        }

        String alias() { return parameters().alias(); }

        PasswordProtection keyProtection() {
            return parameters().keyProtection();
        }
    }
}
